{
  "version": 3,
  "sources": ["../src/commandpalette.tsx", "../src/utils.ts", "../src/lib/vscode.ts"],
  "sourcesContent": ["import { Action, ActionPanel, List, showHUD, popToRoot, showToast, Toast, Icon } from \"@raycast/api\";\nimport { useEffect, useState } from \"react\";\nimport { fileExists, getErrorMessage, openURIinVSCode, raycastForVSCodeURI, waitForFileExists } from \"./utils\";\nimport * as afs from \"fs/promises\";\nimport * as os from \"os\";\nimport path from \"path\";\nimport { getBuildNamePreference, getBuildScheme } from \"./lib/vscode\";\n\ninterface CommandMetadata {\n  command: string;\n  title: string;\n  category?: string;\n}\n\nfunction transitFolder(): string {\n  const build = getBuildNamePreference();\n  const ts = path.join(\n    os.homedir(),\n    `Library/Application Support/${build}/User/globalStorage/tonka3000.raycast/transit`\n  );\n  return ts;\n}\n\nfunction CreateCommandQuickLinkAction(props: { command: CommandMetadata }): JSX.Element {\n  const c = props.command;\n  const title = c.category ? `${c.category}: ${c.title}` : c.title;\n  return (\n    <Action.CreateQuicklink\n      shortcut={{ modifiers: [\"cmd\"], key: \"l\" }}\n      quicklink={{ link: raycastForVSCodeURI(`runcommand?cmd=${c.command}`), name: `VSCode - ${title}` }}\n    />\n  );\n}\n\nasync function getCommandFromVSCode() {\n  const tsFolder = transitFolder();\n  await afs.mkdir(tsFolder, { recursive: true });\n  const requestFilename = path.join(tsFolder, \"request.json\");\n  const responseFilename = path.join(tsFolder, \"commands.json\");\n  await afs.writeFile(\n    requestFilename,\n    JSON.stringify(\n      {\n        command: \"writecommands\",\n        args: {\n          filename: responseFilename,\n        },\n      },\n      null,\n      2\n    )\n  );\n  if (await fileExists(responseFilename)) {\n    await afs.rm(responseFilename);\n  }\n  if (await waitForFileExists(responseFilename)) {\n    const cmds = await readCommandsFile(responseFilename);\n    return cmds;\n  }\n  throw new Error(\"Could not get VSCode commands\");\n}\n\nfunction CommandListItem(props: { command: CommandMetadata }): JSX.Element {\n  const c = props.command;\n  const title = (c: CommandMetadata) => {\n    if (c.category) {\n      return `${c.category}: ${c.title}`;\n    } else {\n      return c.title;\n    }\n  };\n  const handle = async () => {\n    try {\n      await openURIinVSCode(`runcommand?cmd=${c.command}`);\n      popToRoot();\n    } catch (error) {\n      showToast({ style: Toast.Style.Failure, title: \"Could not run Command\", message: getErrorMessage(error) });\n    }\n  };\n  return (\n    <List.Item\n      title={title(c)}\n      actions={\n        <ActionPanel>\n          <ActionPanel.Section>\n            <Action title=\"Run Command\" onAction={handle} icon={{ source: Icon.Terminal }} />\n            <CreateCommandQuickLinkAction command={c} />\n          </ActionPanel.Section>\n          <ActionPanel.Section>\n            <Action.CopyToClipboard\n              shortcut={{ modifiers: [\"cmd\", \"shift\"], key: \".\" }}\n              title=\"Copy Command ID\"\n              content={c.command}\n            />\n          </ActionPanel.Section>\n        </ActionPanel>\n      }\n    />\n  );\n}\n\nfunction InstallRaycastForVSCodeAction(): JSX.Element {\n  return (\n    <Action.OpenInBrowser\n      title=\"Install Raycast for VSCode\"\n      url={`${getBuildScheme()}:extension/tonka3000.raycast`}\n      onOpen={() => {\n        popToRoot();\n        showHUD(\"Open VSCode Extension\");\n      }}\n    />\n  );\n}\n\nexport default function CommandPaletteCommand(): JSX.Element {\n  const { isLoading, commands, error, refresh } = useCommands();\n  if (error) {\n    showToast({ style: Toast.Style.Failure, title: \"Error\", message: error });\n  }\n  return (\n    <List\n      isLoading={isLoading}\n      searchBarPlaceholder={isLoading === true ? \"Load Commands from VSCode\" : \"Search Commands\"}\n    >\n      <List.Section title=\"Commands\" subtitle={`${commands?.length}`}>\n        {commands?.map((c) => (\n          <CommandListItem key={c.command} command={c} />\n        ))}\n      </List.Section>\n      {error && (\n        <List.EmptyView\n          title=\"No Response from Raycast for VSCode extension\"\n          icon=\"\u26A0\uFE0F\"\n          actions={\n            <ActionPanel>\n              <Action\n                title=\"Reload\"\n                icon={Icon.RotateClockwise}\n                shortcut={{ modifiers: [\"cmd\"], key: \"r\" }}\n                onAction={refresh}\n              />\n              <InstallRaycastForVSCodeAction />\n            </ActionPanel>\n          }\n        />\n      )}\n    </List>\n  );\n}\n\nasync function readCommandsFile(filename: string): Promise<CommandMetadata[] | undefined> {\n  const data = await afs.readFile(filename, \"utf-8\");\n  const result = JSON.parse(data) as CommandMetadata[] | undefined;\n  await afs.rm(filename);\n  return result;\n}\n\nfunction useCommands(): {\n  commands: CommandMetadata[] | undefined;\n  isLoading?: boolean;\n  error?: string;\n  refresh?: () => void;\n} {\n  const [isLoading, setIsLoading] = useState(true);\n  const [commands, setCommands] = useState<CommandMetadata[]>();\n  const [error, setError] = useState<string>();\n  const [date, setDate] = useState(new Date());\n\n  const refresh = () => {\n    setDate(new Date());\n  };\n\n  useEffect(() => {\n    let didUnmount = false;\n    async function fetchCommands() {\n      if (didUnmount) {\n        return;\n      }\n      setIsLoading(true);\n      setError(undefined);\n      try {\n        const cmds = await getCommandFromVSCode();\n        if (!didUnmount) {\n          setCommands(cmds);\n        }\n      } catch (error) {\n        if (!didUnmount) {\n          setError(getErrorMessage(error));\n        }\n      } finally {\n        if (!didUnmount) {\n          setIsLoading(false);\n        }\n      }\n    }\n    fetchCommands();\n    return () => {\n      didUnmount = true;\n    };\n  }, [date]);\n\n  return { commands, isLoading, error, refresh };\n}\n", "import { existsSync } from \"fs\";\nimport { URL } from \"url\";\nimport { isDeepStrictEqual } from \"util\";\nimport {\n  EntryType,\n  EntryLike,\n  FileEntry,\n  FolderEntry,\n  RemoteEntry,\n  WorkspaceEntry,\n  RemoteWorkspaceEntry,\n} from \"./types\";\nimport { open } from \"@raycast/api\";\nimport * as fs from \"fs\";\nimport { getBuildScheme } from \"./lib/vscode\";\n\n// Type Guards\n\nexport function isFileEntry(entry: EntryLike): entry is FileEntry {\n  const { fileUri } = entry as FileEntry;\n\n  if (fileUri === undefined) {\n    return false;\n  }\n\n  try {\n    const fileUrl = new URL(fileUri);\n    return existsSync(fileUrl) && fileUri.indexOf(\".code-workspace\") === -1;\n  } catch (error) {\n    return false;\n  }\n}\n\nexport function isFolderEntry(entry: EntryLike): entry is FolderEntry {\n  const { folderUri } = entry as FolderEntry;\n\n  if (folderUri === undefined) {\n    return false;\n  }\n\n  try {\n    const folderUrl = new URL(folderUri);\n    return existsSync(folderUrl);\n  } catch (error) {\n    return false;\n  }\n}\n\nexport function isWorkspaceEntry(entry: EntryLike): entry is WorkspaceEntry {\n  const { workspace } = entry as WorkspaceEntry;\n\n  if (workspace === undefined) {\n    return false;\n  }\n\n  try {\n    const configUrl = new URL(workspace.configPath);\n    return existsSync(configUrl) && workspace.configPath.indexOf(\".code-workspace\") !== -1;\n  } catch (error) {\n    return false;\n  }\n}\n\nexport function isRemoteEntry(entry: EntryLike): entry is RemoteEntry {\n  const { folderUri, remoteAuthority } = entry as RemoteEntry;\n  return folderUri !== undefined && remoteAuthority !== undefined;\n}\n\nexport function isRemoteWorkspaceEntry(entry: EntryLike): entry is RemoteWorkspaceEntry {\n  const { workspace, remoteAuthority } = entry as RemoteWorkspaceEntry;\n  return workspace !== undefined && remoteAuthority !== undefined;\n}\n\nexport function isSameEntry(a: EntryLike, b: EntryLike) {\n  if (\"fileUri\" in a && \"fileUri\" in b) {\n    return a.fileUri === b.fileUri;\n  }\n\n  if (\"folderUri\" in a && \"folderUri\" in b) {\n    return a.folderUri === b.folderUri;\n  }\n\n  if (\"workspace\" in a && \"workspace\" in b) {\n    return a.workspace.configPath === b.workspace.configPath;\n  }\n\n  return false;\n}\n\n// Filters\n\nexport function filterEntriesByType(filter: EntryType | null) {\n  switch (filter) {\n    case \"All Types\":\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      return (entry: EntryLike) => true;\n    case \"Workspaces\":\n      return isWorkspaceEntry;\n    case \"Folders\":\n      return isFolderEntry;\n    case \"Remote Folders\":\n      return isRemoteEntry;\n    case \"Remote Workspace\":\n      return isRemoteWorkspaceEntry;\n    case \"Files\":\n      return isFileEntry;\n    default:\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      return (entry: EntryLike) => false;\n  }\n}\n\nexport function filterUnpinnedEntries(pinnedEntries: EntryLike[]) {\n  return (entry: EntryLike) => pinnedEntries.find((pinnedEntry) => isDeepStrictEqual(pinnedEntry, entry)) === undefined;\n}\n\nexport function getErrorMessage(error: unknown): string {\n  return error instanceof Error ? error.message : \"unknown error\";\n}\n\nexport async function fileExists(filename: string): Promise<boolean> {\n  return fs.promises\n    .access(filename, fs.constants.F_OK)\n    .then(() => true)\n    .catch(() => false);\n}\n\nconst fmt = new Intl.NumberFormat(\"en\", { notation: \"compact\" });\n\nexport function compactNumberFormat(num: number): string {\n  return fmt.format(num);\n}\n\nexport function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport async function waitForFileExists(filename: string, timeoutMs = 2000) {\n  const start = new Date();\n  while (start.getTime() > 0) {\n    await sleep(10);\n    if (await fileExists(filename)) {\n      return true;\n    }\n    const end = new Date();\n    const delta = end.getTime() - start.getTime();\n    if (delta > timeoutMs) {\n      return false;\n    }\n  }\n  return false;\n}\n\nexport function raycastForVSCodeURI(uri: string) {\n  return `${getBuildScheme()}://tonka3000.raycast/${uri}`;\n}\n\nexport async function openURIinVSCode(uri: string) {\n  await open(raycastForVSCodeURI(uri));\n}\n", "import { fileExists } from \"../utils\";\nimport * as afs from \"fs/promises\";\nimport * as os from \"os\";\nimport path from \"path\";\nimport * as child_process from \"child_process\";\nimport { getPreferenceValues } from \"@raycast/api\";\n\ninterface ExtensionMetaRoot {\n  identifier: ExtensionIdentifier;\n  version: string;\n  location: ExtensionLocation | string;\n  metadata?: ExtensionMetadata;\n}\n\ninterface ExtensionIdentifier {\n  id: string;\n  uuid: string;\n}\n\ninterface ExtensionLocation {\n  $mid: number;\n  fsPath: string;\n  path: string;\n  scheme: string;\n}\n\ninterface ExtensionMetadata {\n  id: string;\n  publisherId?: string;\n  publisherDisplayName?: string;\n  targetPlatform?: string;\n  isApplicationScoped?: boolean;\n  updated?: boolean;\n  isPreReleaseVersion: boolean;\n  installedTimestamp?: number;\n  preRelease?: boolean;\n}\n\nexport interface Extension {\n  id: string;\n  name: string;\n  version: string;\n  preRelease?: boolean;\n  icon?: string;\n  updated?: boolean;\n  fsPath: string;\n  publisherId?: string;\n  publisherDisplayName?: string;\n  preview?: boolean;\n  installedTimestamp?: number;\n}\n\ninterface PackageJSONInfo {\n  displayName?: string;\n  icon?: string;\n  preview?: boolean;\n}\n\nfunction getNLSVariable(text: string | undefined): string | undefined {\n  if (!text) {\n    return text;\n  }\n  const m = text.match(/%(.+)%/);\n  if (m) {\n    return m[1];\n  }\n}\nconst cliPaths: Record<string, string> = {\n  Code: \"/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code\",\n  \"Code - Insiders\": \"/Applications/Visual Studio Code - Insiders.app/Contents/Resources/app/bin/code\",\n  Cursor: \"/Applications/Cursor.app/Contents/Resources/app/bin/cursor\", // it also has code, which is an alias\n  VSCodium: \"/Applications/VSCodium.app/Contents/Resources/app/bin/codium\",\n};\n\nexport function getVSCodeCLIFilename(): string {\n  const name = cliPaths[getBuildNamePreference()];\n  if (!name || name.length <= 0) {\n    return cliPaths.Code;\n  }\n  return name;\n}\n\nexport class VSCodeCLI {\n  private cliFilename: string;\n  constructor(cliFilename: string) {\n    this.cliFilename = cliFilename;\n  }\n  installExtensionByIDSync(id: string) {\n    child_process.execFileSync(this.cliFilename, [\"--install-extension\", id, \"--force\"]);\n  }\n  uninstallExtensionByIDSync(id: string) {\n    child_process.execFileSync(this.cliFilename, [\"--uninstall-extension\", id, \"--force\"]);\n  }\n}\n\nexport function getVSCodeCLI(): VSCodeCLI {\n  return new VSCodeCLI(getVSCodeCLIFilename());\n}\n\nasync function getPackageJSONInfo(filename: string): Promise<PackageJSONInfo | undefined> {\n  try {\n    if (await fileExists(filename)) {\n      const packageJSONData = await afs.readFile(filename, { encoding: \"utf-8\" });\n      const packageJSON = JSON.parse(packageJSONData);\n      let displayName = packageJSON.displayName as string | undefined;\n      const nlsVariable = getNLSVariable(displayName);\n      const iconFilename = packageJSON.icon as string | undefined;\n      const folder = path.dirname(filename);\n      if (nlsVariable && nlsVariable.length > 0) {\n        const nlsFilename = path.join(folder, \"package.nls.json\");\n        try {\n          if (await fileExists(nlsFilename)) {\n            const nlsContent = await afs.readFile(nlsFilename, { encoding: \"utf-8\" });\n            const nlsJSON = JSON.parse(nlsContent);\n            const displayNameNLS = nlsJSON[nlsVariable] as string | undefined;\n            if (displayNameNLS && displayNameNLS.length > 0) {\n              displayName = displayNameNLS;\n            }\n          }\n        } catch (error) {\n          // ignore\n        }\n      }\n      const preview = packageJSON.preview as boolean | undefined;\n      const icon = iconFilename ? path.join(folder, iconFilename) : undefined;\n      return {\n        displayName,\n        icon,\n        preview,\n      };\n    }\n  } catch (error) {\n    //\n  }\n}\n\nexport async function getLocalExtensions(): Promise<Extension[] | undefined> {\n  const extensionsRootFolder = path.join(os.homedir(), `.${getBuildScheme()}/extensions`);\n  const extensionsManifrestFilename = path.join(extensionsRootFolder, \"extensions.json\");\n  if (await fileExists(extensionsManifrestFilename)) {\n    const data = await afs.readFile(extensionsManifrestFilename, { encoding: \"utf-8\" });\n    const extensions = JSON.parse(data) as ExtensionMetaRoot[] | undefined;\n    if (extensions && extensions.length > 0) {\n      const result: Extension[] = [];\n      for (const e of extensions) {\n        const extFsPath =\n          typeof e.location === \"string\"\n            ? path.join(extensionsRootFolder, e.location)\n            : e.location.fsPath ?? e.location.path;\n        const packageFilename = path.join(extFsPath, \"package.json\");\n        const pkgInfo = await getPackageJSONInfo(packageFilename);\n        result.push({\n          id: e.identifier.id,\n          name: pkgInfo?.displayName || e.identifier.id,\n          version: e.version,\n          preRelease: e.metadata?.preRelease,\n          icon: pkgInfo?.icon,\n          updated: e.metadata?.updated,\n          fsPath: extFsPath,\n          publisherId: e.metadata?.publisherId,\n          publisherDisplayName: e.metadata?.publisherDisplayName,\n          preview: pkgInfo?.preview,\n          installedTimestamp: e.metadata?.installedTimestamp,\n        });\n      }\n      return result;\n    }\n  }\n  return undefined;\n}\n\nexport function getBuildNamePreference(): string {\n  const prefs = getPreferenceValues();\n  const build = prefs.build as string;\n  return build;\n}\n\nconst buildSchemes: Record<string, string> = {\n  Code: \"vscode\",\n  \"Code - Insiders\": \"vscode-insiders\",\n  Cursor: \"cursor\",\n  VSCodium: \"vscode-oss\",\n};\n\nexport function getBuildScheme(): string {\n  const scheme = buildSchemes[getBuildNamePreference()] as string | undefined;\n  if (!scheme || scheme.length <= 0) {\n    return buildSchemes.Code;\n  }\n  return scheme;\n}\n"],
  "mappings": "0jBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAAsF,wBACtFC,EAAoC,iBCWpC,IAAAC,EAAqB,wBACrBC,EAAoB,iBCRpB,IAAAC,EAAoC,wBAsK7B,SAASC,GAAiC,CAG/C,SAFc,uBAAoB,EACd,KAEtB,CAEA,IAAMC,EAAuC,CAC3C,KAAM,SACN,kBAAmB,kBACnB,OAAQ,SACR,SAAU,YACZ,EAEO,SAASC,GAAyB,CACvC,IAAMC,EAASF,EAAaD,EAAuB,CAAC,EACpD,MAAI,CAACG,GAAUA,EAAO,QAAU,EACvBF,EAAa,KAEfE,CACT,CD1EO,SAASC,EAAgBC,EAAwB,CACtD,OAAOA,aAAiB,MAAQA,EAAM,QAAU,eAClD,CAEA,eAAsBC,EAAWC,EAAoC,CACnE,OAAU,WACP,OAAOA,EAAa,YAAU,IAAI,EAClC,KAAK,IAAM,EAAI,EACf,MAAM,IAAM,EAAK,CACtB,CAEA,IAAMC,EAAM,IAAI,KAAK,aAAa,KAAM,CAAE,SAAU,SAAU,CAAC,EAMxD,SAASC,EAAMC,EAAY,CAChC,OAAO,IAAI,QAASC,GAAY,WAAWA,EAASD,CAAE,CAAC,CACzD,CAEA,eAAsBE,EAAkBC,EAAkBC,EAAY,IAAM,CAC1E,IAAMC,EAAQ,IAAI,KAClB,KAAOA,EAAM,QAAQ,EAAI,GAAG,CAE1B,GADA,MAAMN,EAAM,EAAE,EACV,MAAMO,EAAWH,CAAQ,EAC3B,MAAO,GAIT,GAFY,IAAI,KAAK,EACH,QAAQ,EAAIE,EAAM,QAAQ,EAChCD,EACV,MAAO,GAGX,MAAO,EACT,CAEO,SAASG,EAAoBC,EAAa,CAC/C,MAAO,GAAGC,EAAe,yBAAyBD,GACpD,CAEA,eAAsBE,EAAgBF,EAAa,CACjD,QAAM,QAAKD,EAAoBC,CAAG,CAAC,CACrC,CD5JA,IAAAG,EAAqB,0BACrBC,EAAoB,iBACpBC,EAAiB,mBAsBb,IAAAC,EAAA,6BAbJ,SAASC,GAAwB,CAC/B,IAAMC,EAAQC,EAAuB,EAKrC,OAJW,EAAAC,QAAK,KACX,UAAQ,EACX,+BAA+BF,gDACjC,CAEF,CAEA,SAASG,EAA6BC,EAAkD,CACtF,IAAMC,EAAID,EAAM,QACVE,EAAQD,EAAE,SAAW,GAAGA,EAAE,aAAaA,EAAE,QAAUA,EAAE,MAC3D,SACE,OAAC,SAAO,gBAAP,CACC,SAAU,CAAE,UAAW,CAAC,KAAK,EAAG,IAAK,GAAI,EACzC,UAAW,CAAE,KAAME,EAAoB,kBAAkBF,EAAE,SAAS,EAAG,KAAM,YAAYC,GAAQ,EACnG,CAEJ,CAEA,eAAeE,GAAuB,CACpC,IAAMC,EAAWV,EAAc,EAC/B,MAAU,QAAMU,EAAU,CAAE,UAAW,EAAK,CAAC,EAC7C,IAAMC,EAAkB,EAAAR,QAAK,KAAKO,EAAU,cAAc,EACpDE,EAAmB,EAAAT,QAAK,KAAKO,EAAU,eAAe,EAiB5D,GAhBA,MAAU,YACRC,EACA,KAAK,UACH,CACE,QAAS,gBACT,KAAM,CACJ,SAAUC,CACZ,CACF,EACA,KACA,CACF,CACF,EACI,MAAMC,EAAWD,CAAgB,GACnC,MAAU,KAAGA,CAAgB,EAE3B,MAAME,EAAkBF,CAAgB,EAE1C,OADa,MAAMG,EAAiBH,CAAgB,EAGtD,MAAM,IAAI,MAAM,+BAA+B,CACjD,CAEA,SAASI,EAAgBX,EAAkD,CACzE,IAAMC,EAAID,EAAM,QACVE,EAASD,GACTA,EAAE,SACG,GAAGA,EAAE,aAAaA,EAAE,QAEpBA,EAAE,MAGPW,EAAS,SAAY,CACzB,GAAI,CACF,MAAMC,EAAgB,kBAAkBZ,EAAE,SAAS,KACnD,aAAU,CACZ,OAASa,EAAP,IACA,aAAU,CAAE,MAAO,QAAM,MAAM,QAAS,MAAO,wBAAyB,QAASC,EAAgBD,CAAK,CAAE,CAAC,CAC3G,CACF,EACA,SACE,OAAC,OAAK,KAAL,CACC,MAAOZ,EAAMD,CAAC,EACd,WACE,QAAC,eACC,qBAAC,cAAY,QAAZ,CACC,oBAAC,UAAO,MAAM,cAAc,SAAUW,EAAQ,KAAM,CAAE,OAAQ,OAAK,QAAS,EAAG,KAC/E,OAACb,EAAA,CAA6B,QAASE,EAAG,GAC5C,KACA,OAAC,cAAY,QAAZ,CACC,mBAAC,SAAO,gBAAP,CACC,SAAU,CAAE,UAAW,CAAC,MAAO,OAAO,EAAG,IAAK,GAAI,EAClD,MAAM,kBACN,QAASA,EAAE,QACb,EACF,GACF,EAEJ,CAEJ,CAEA,SAASe,GAA6C,CACpD,SACE,OAAC,SAAO,cAAP,CACC,MAAM,6BACN,IAAK,GAAGC,EAAe,gCACvB,OAAQ,IAAM,IACZ,aAAU,KACV,WAAQ,uBAAuB,CACjC,EACF,CAEJ,CAEe,SAARC,GAAsD,CAC3D,GAAM,CAAE,UAAAC,EAAW,SAAAC,EAAU,MAAAN,EAAO,QAAAO,CAAQ,EAAIC,EAAY,EAC5D,OAAIR,MACF,aAAU,CAAE,MAAO,QAAM,MAAM,QAAS,MAAO,QAAS,QAASA,CAAM,CAAC,KAGxE,QAAC,QACC,UAAWK,EACX,qBAAsBA,IAAc,GAAO,4BAA8B,kBAEzE,oBAAC,OAAK,QAAL,CAAa,MAAM,WAAW,SAAU,GAAGC,GAAU,SACnD,SAAAA,GAAU,IAAKnB,MACd,OAACU,EAAA,CAAgC,QAASV,GAApBA,EAAE,OAAqB,CAC9C,EACH,EACCa,MACC,OAAC,OAAK,UAAL,CACC,MAAM,gDACN,KAAK,eACL,WACE,QAAC,eACC,oBAAC,UACC,MAAM,SACN,KAAM,OAAK,gBACX,SAAU,CAAE,UAAW,CAAC,KAAK,EAAG,IAAK,GAAI,EACzC,SAAUO,EACZ,KACA,OAACL,EAAA,EAA8B,GACjC,EAEJ,GAEJ,CAEJ,CAEA,eAAeN,EAAiBa,EAA0D,CACxF,IAAMC,EAAO,MAAU,WAASD,EAAU,OAAO,EAC3CE,EAAS,KAAK,MAAMD,CAAI,EAC9B,aAAU,KAAGD,CAAQ,EACdE,CACT,CAEA,SAASH,GAKP,CACA,GAAM,CAACH,EAAWO,CAAY,KAAI,YAAS,EAAI,EACzC,CAACN,EAAUO,CAAW,KAAI,YAA4B,EACtD,CAACb,EAAOc,CAAQ,KAAI,YAAiB,EACrC,CAACC,EAAMC,CAAO,KAAI,YAAS,IAAI,IAAM,EAErCT,EAAU,IAAM,CACpBS,EAAQ,IAAI,IAAM,CACpB,EAEA,sBAAU,IAAM,CACd,IAAIC,EAAa,GACjB,eAAeC,GAAgB,CAC7B,GAAI,CAAAD,EAGJ,CAAAL,EAAa,EAAI,EACjBE,EAAS,MAAS,EAClB,GAAI,CACF,IAAMK,EAAO,MAAM7B,EAAqB,EACnC2B,GACHJ,EAAYM,CAAI,CAEpB,OAASnB,EAAP,CACKiB,GACHH,EAASb,EAAgBD,CAAK,CAAC,CAEnC,QAAE,CACKiB,GACHL,EAAa,EAAK,CAEtB,EACF,CACA,OAAAM,EAAc,EACP,IAAM,CACXD,EAAa,EACf,CACF,EAAG,CAACF,CAAI,CAAC,EAEF,CAAE,SAAAT,EAAU,UAAAD,EAAW,MAAAL,EAAO,QAAAO,CAAQ,CAC/C",
  "names": ["commandpalette_exports", "__export", "CommandPaletteCommand", "__toCommonJS", "import_api", "import_react", "import_api", "fs", "import_api", "getBuildNamePreference", "buildSchemes", "getBuildScheme", "scheme", "getErrorMessage", "error", "fileExists", "filename", "fmt", "sleep", "ms", "resolve", "waitForFileExists", "filename", "timeoutMs", "start", "fileExists", "raycastForVSCodeURI", "uri", "getBuildScheme", "openURIinVSCode", "afs", "os", "import_path", "import_jsx_runtime", "transitFolder", "build", "getBuildNamePreference", "path", "CreateCommandQuickLinkAction", "props", "c", "title", "raycastForVSCodeURI", "getCommandFromVSCode", "tsFolder", "requestFilename", "responseFilename", "fileExists", "waitForFileExists", "readCommandsFile", "CommandListItem", "handle", "openURIinVSCode", "error", "getErrorMessage", "InstallRaycastForVSCodeAction", "getBuildScheme", "CommandPaletteCommand", "isLoading", "commands", "refresh", "useCommands", "filename", "data", "result", "setIsLoading", "setCommands", "setError", "date", "setDate", "didUnmount", "fetchCommands", "cmds"]
}
